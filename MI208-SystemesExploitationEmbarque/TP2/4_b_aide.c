// ---------------------------------------------------------------------
// Fichier d'exemple pour le TP2 Question 4-a --> création des timers
// VO par Christophe BLAESS
// Adapté par Jalil Boukhobza
// ---------------------------------------------------------------------

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#include <sched.h>

static timer_t timer = (timer_t) 0;
static long int * mesure = NULL;
static int nb_mesures = 0;
static int nb_total_mesures = 0;

// Fonction associée au déclenchement du signal
void handler_signal(int inutilise){
	struct timespec heure;
	static struct timespec precedente = { 0, 0} ;

	// Mesure du temps
	clock_gettime(CLOCK_REALTIME,&heure);
	
	if (precedente.tv_sec > 0) {
		// On stocke la difference entre mesure actuelle et precedente
		mesure[nb_mesures] = (heure.tv_sec-precedente.tv_sec) + (heure.tv_nsec-precedente.tv_nsec);
		// On incremente notre nombre de mesures
		nb_mesures = nb_mesures+1;
	}
	precedente = heure;

	if (nb_mesures == nb_total_mesures)
		timer_delete(timer);
}


int main(int argc, char * argv[]){
	long int periode_us;
	long int periode_ns;
	struct sigevent event;
	struct itimerspec spec;

	// /!\ TEMPS REEL -- Uniquement utilise pour Q5 /!\ 
	// cf. programme 1-3.c
	printf("Le processus passe en temps reel\n");
	struct sched_param p;
	struct sched_param resultStruct;	
	int monPid = getpid();
	p.sched_priority = 99;
	sched_setscheduler(monPid,SCHED_FIFO,&p);
	int result = sched_getparam(monPid,&resultStruct);

	if ((argc != 2) || (sscanf(argv[1], "%ld", & periode_us) != 1)){
		fprintf(stderr, "usage: %s periode_en_microsec\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	
	// nombre de mesues réalisées en 5 secondes 
	nb_total_mesures = 5000000 / periode_us; 
	
	// Allocation mémoire du tableau mesure
	mesure = calloc(nb_total_mesures, sizeof(long int*));

	// A la reception du signal SIGRTMIN, executer la fonction handler_signal()
	signal(SIGRTMIN, handler_signal);
	
	// Notification du signal
	event.sigev_notify = SIGEV_SIGNAL;
	event.sigev_signo = SIGRTMIN;
	event.sigev_value.sival_ptr = &timer;

	periode_ns = periode_us * 1000;  // en nanosec
	
	// Configurer le timer
	spec.it_interval.tv_sec 			= 0;
	spec.it_interval.tv_nsec 			= periode_ns;
	spec.it_value = spec.it_interval;
	
	
	// Allouer le timer	
	if (timer_create(CLOCK_REALTIME, &event, &timer) != 0){
		perror("timer_create");
		exit(EXIT_FAILURE);
	}

	// Programmer le timer
	if (timer_settime(timer, 0, &spec, NULL) != 0){
		perror("timer_settime");
		exit(EXIT_FAILURE);
	}
	
	// Attendre le dernier signal
	while (nb_mesures < nb_total_mesures)
		pause();
		
	// Afficher les mesures en micro-secondes
	for (nb_mesures = 0; nb_mesures < nb_total_mesures; nb_mesures ++)
		printf("%ld\n", mesure[nb_mesures]/1000);
		
	return EXIT_SUCCESS;
}

